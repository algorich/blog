<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testes | Blog da Algorich]]></title>
  <link href="http://blog.algorich.com.br/categories/testes/atom.xml" rel="self"/>
  <link href="http://blog.algorich.com.br/"/>
  <updated>2014-10-24T14:44:35-02:00</updated>
  <id>http://blog.algorich.com.br/</id>
  <author>
    <name><![CDATA[Time Algorich]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Conheça os test helpers: #travel_to e #travel_back no Rails 4.1]]></title>
    <link href="http://blog.algorich.com.br/2014/05/23/conheca-os-test-helpers-travel_to-e-travel_back-no-rails-4-1/"/>
    <updated>2014-05-23T17:00:00-03:00</updated>
    <id>http://blog.algorich.com.br/2014/05/23/conheca-os-test-helpers-travel_to-e-travel_back-no-rails-4-1</id>
    <content type="html"><![CDATA[<p>Quem trabalha com testes no Ruby on Rails certamente já teve de recorrer a gem <a href="https://github.com/travisjeffery/timecop" target="_blank">timecop</a> para cobrir os testes com dependências de tempo.</p>

<p>Como exemplo, posso citar a regra de negócio de um seguinte cenário:</p>

<p>O pagamento de um aluguel deve ser realizado em uma data específica de cada mês, exceto quando esse data cai em um fim de semana. Nesse caso, o pagamento será realizado na próxima segunda-feira.</p>

<!-- more -->


<p><img class="alignright" title="ilustração: de volta para o futuro" src="http://blog.algorich.com.br/posts-assets/images/2014/05/back-future.jpg" alt="ilustração: de volta para o futuro" width="250" height="250" /></p>

<p><strong>Onde a gem timecop atua?</strong></p>

<p>Timecop é uma gem que provê à nossa aplicação a capacidade de viajar ou parar no tempo, isso permite que consigamos realizar testes com dependência de tempo de forma muito simples, e certamente assegurar os testes para a nossa regra de negócio detalhada acima.</p>

<h2>Os test helpers #travel_to e #travel_back</h2>

<p>Com a <a href="http://guides.rubyonrails.org/4_1_release_notes.html" target="_blank">nova release do Rails 4.1</a>, agora temos os métodos: <em>#travel_to</em> e <em>#travel_back</em>.</p>

<p>Com o <em>#travel_to</em> podemos facilmente alterar o dia e horário fornecendo um valor ou duração de tempo. Já o <em>#travel_back</em> faz com que retornemos ao estágio atual, desfazendo as alterações do <em>#travel_to</em>.</p>

<p>Essa feature teve um destaque muito pequeno (o que não diminui sua importância, na minha opinião), sendo mencionada apenas no final das notas da release:</p>

<p><img title="release notes: travel_to / travel_back" src="http://blog.algorich.com.br/posts-assets/images/2014/05/travel-to.png" alt="release notes: travel_to / travel_back" width="670" height="389" /></p>

<h4>Editado em 24/10/2014</h4>

<h2>Exemplo de uso</h2>

<p>``` ruby
describe SomeObject do
  include ActiveSupport::Testing::TimeHelpers</p>

<p>  it 'works with the new stuff' do</p>

<pre><code>the_thing = SomeObject.new
</code></pre>

<p>  # Executes travel back after the block yields</p>

<pre><code>travel_to(1.day.ago) do
  expect(the_thing.works_with_new_stuff?).to eq true
end
</code></pre>

<p>  end
end
```</p>

<p>Referência: <a href="http://brandonhilkert.com/blog/rails-4-1-travel-to-test-helper/" target="_blank">http://brandonhilkert.com/blog/rails-4-1-travel-to-test-helper/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boa prática em testes & cuidados com FactoryGirl]]></title>
    <link href="http://blog.algorich.com.br/2014/05/13/cuidados-no-uso-de-factories-factorygirl/"/>
    <updated>2014-05-13T08:30:00-03:00</updated>
    <id>http://blog.algorich.com.br/2014/05/13/cuidados-no-uso-de-factories-factorygirl</id>
    <content type="html"><![CDATA[<p><em>FactoryGirl</em> é uma das melhores opções para criação de factories no Rails. Seu uso contínuo se torna conveniênte em equipes, já que esta aplicação
gera objetos carregados de dados de maneira simples, prontos para serem utilizados num ambiente de teste. No entanto, tal comodidade pode vir a ser a futura dor de cabeça no quesito performance.</p>

<p>Irei mostrar os principais motivos pelo qual devemos ter cuidado ao utilizar o FactoryGirl.</p>

<!-- more -->


<p><strong>Existiria grande diferença entre estes dois exemplos?</strong></p>

<p><code>ruby
@event = Factory.build :event
</code></p>

<p><code>ruby
@event = Event.new
</code></p>

<p>Tudo depende de nossa definição na factory Event:</p>

<p>```ruby
FactoryGirl.define do
  factory :event do</p>

<pre><code>organizer
name 'Corrida'
sequence(:slug) { |n| "corrida#{n}" }
address 'Avenida 123 - n 12'
phone '(22) 2734-0503'
email 'hi@mail.com'
</code></pre>

<p>  end
end
```</p>

<p>Utilizando esta factory nós não iremos apenas criar um novo objeto Event. Criaremos também um objeto Organizer, que é uma <strong>dependência</strong> de Event. Ou seja, estamos acessando a factory de organizer e definindo um objeto que muitas vezes nem iremos utilizar no teste.</p>

<hr />

<h1>Performance</h1>

<hr />

<p><code>ruby
Benchmark.realtime { 100.times { FactoryGirl.build :event } }
=&gt; 12.933986
</code></p>

<p><code>ruby
Benchmark.realtime { 100.times { Event.new } }
=&gt; 0.021129
</code></p>

<p>Este exemplo mostra a implicação do uso inconsequente da FactoryGirl. Imagine quanto tempo acabamos perdendo em testes unitários que devem ser rodados constantemente. O principal fator causador de problemas de performance no primeiro caso é o acesso ao banco de dados. O FactoryGirl#build, apesar de não salvar o próprio objeto Event, ele possui um comportamento que sempre salva as dependências do objeto passado para este método, neste caso, o objeto Organizer.</p>

<p>Muitas vezes, a melhor opção para os casos em que precisemos do objeto salvo no banco de dados é um simples <strong>#create</strong>.</p>

<hr />

<h1>Alto acoplamento</h1>

<hr />

<p>Velocidade nos testes é uma qualidade essencial, porém este não é o principal argumento para evitar o uso do FactoryGirl em testes unitários.</p>

<p>Ambientes de teste crescem, ficam complexos (assim como a aplicação), e chegam no ponto de visível lentidão para a prática de TDD por motivos citados acima. Quando isto acontece em testes unitários, algo está errado. Acabamos aceitando uma certa comodidade criada pelo alto acoplamento dos objetos gerados pelo FactoryGirl, e perdemos a especificidade do teste em questão.</p>

<h2>Exemplo:</h2>

<p>Imagine a utilização desta factory:</p>

<p>```ruby
FactoryGirl.define do
  factory :event do</p>

<pre><code>organizer
expired false
open_to_enrollment true
name 'Corrida'
email 'hi@mail.com'
</code></pre>

<p>  end
end
```</p>

<p>Facilmente percebemos que caso alguém
tente descobrir a utilização do método Event#can_enroll? pelo primeiro exemplo
(utilizando FactoryGirl), não entenderá de fato o que o método faz.</p>

<p>Ou seja, além de ser muito mais custoso, estamos sendo implícitos.</p>

<p><strong>Com FactoryGirl</strong></p>

<p>```ruby
describe Event do
  it '#can_enroll?' do</p>

<pre><code>event = FactoryGirl.build :event, open_to_enrollments: true
expect(event.can_enroll?).to be_true
</code></pre>

<p>  end
end
```</p>

<p><strong>Sem FactoryGirl</strong></p>

<p>```ruby
describe Event do
  it '#can_enroll?' do</p>

<pre><code>event = Event.new open_to_enrollments: true, expired: false
expect(event.can_enroll?).to be_true
</code></pre>

<p>  end
end
```</p>

<p><strong>Definição do método</strong></p>

<p>```ruby
class Event
  def can_enroll?</p>

<pre><code>open_to_enrollments &amp;&amp; !expired
</code></pre>

<p>  end
end
```</p>

<p>A questão é que sempre haverão mais validações, e mais dependências, causando um custo muito maior a médio/longo prazo, onde técnicas como Mocking &amp; Stubbing se encaixam perfeitamente, tornando os testes específicos e principalmente unitários novamente.</p>
]]></content>
  </entry>
  
</feed>
